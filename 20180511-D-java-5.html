
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="./css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="./css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="./lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="./img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h3>什么是session？什么是cookie？session和cookie有什么区别？什么场景适用于session？什么场景适用于cookie？</h3>
			<p>小课堂</p>
            <h3></h3>
            <p>分享人：王琦超</p>
        </section>

        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>

        <section>
            <h3>1.背景介绍</h3>
        </section>

         <section>
            <p style="text-align:left">cookie:</p>
			 <p style="text-align:left">在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。</p>
　　        <p style="text-align:left">而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p>
           
             
        </section>
        <section>
            <p style="text-align:left">怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。简单例子就是理发店的会员卡，cookie就相当于我们去理发店办的会员卡，凭借此卡，就可以打折并召唤专属Tony老师。</p>
            <p style="text-align:left">Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客 户端浏览器颁发一个Cookie（写进响应头中）。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>
		
		  <section>
            <p style="text-align:left">session:</p>
            <p style="text-align:left">Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
            <p style="text-align:left">如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>
		  <section>
            <p style="text-align:left">就相当于是理发店的客户信息表，第一次来理发店办卡后就会添加一页你的个人信息表，你的每次消费，什么时间，做了什么项目，哪个老师给你做的都可以选择存到这个表里，你只要凭借自己的会员卡上的id（JSESSIONID)就可以随时去查询这些信息，你在店里消费的时候也可以随时查询（相当于本次会话中使用）。</p>
            <p style="text-align:left">Session对应的类为javax.servlet.http.HttpSession类。每个来访者对应一个Session对象，所有该客户的状态信息都保存在这个Session对象里。Session对象是在客户端第一次请求服务器的时候创建的。（这是一个机制，不需要我们来创建session，我们需要做的就是set和get) Session也是一种key-value的属性对，通过getAttribute(String key)和setAttribute(String key，Object value)方法读写客户状态信息。Servlet里通过request.getSession()方法获取该客户的 Session（从请求头中获取信息）。</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>
		  <section>
            <p style="text-align:left">当多个客户端执行程序时，服务器会保存多个客户端的Session。获取Session的时候也不需要声明获取谁的Session。Session机制决定了当前客户只会获取到自己的Session，而不会获取到别人的Session。各客户的Session也彼此独立，互不可见。</p>
            <p style="text-align:left">Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。</p>
            <p style="text-align:left">Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>
		

        <section>
            <h3>2.知识剖析</h3>
        </section>

        <section>
            <p style="text-align:left">cookie的的基本属性</p>
            <p style="text-align:left">String name：该Cookie的名称。Cookie一旦创建，名称便不可更改</p>
            <p style="text-align:left">Object value：该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码</p>
            <p style="text-align:left">String path：该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”</p>
            <p style="text-align:left"></p>
        </section>

        <section>
            <p style="text-align:left">int maxAge：该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie，因为cookie没有删除的机制，response提供的操作cookie对象的方法只有addCookie(Cookie cookie),所以只能使用同名cookie覆盖，并设置时间为0来删除（注意，修改和删除时，除了value和maxage属性之外，其他属性都得相同，否则浏览器将其视为两个cookie从而导致修改删除失败）。MaxAge默认为–1。可以使用getMaxAge获得，使用setMaxAge设置。</p>
            <p style="text-align:left">String domain：可以访问该Cookie的域名。正常情况下cookie不可跨域名，但如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>

        <section>
            <p style="text-align:left">boolean secure：该Cookie是否仅被使用安全协议传输。HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可 能。使用HTTP协议传输很机密的内容是一种隐患。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为 true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。</p>
            <p style="text-align:left">String comment：该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</p>
            <p style="text-align:left">int version：该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范</p>
        </section>
		
		 <section>
            <p style="text-align:left">session的基本方法</p>
            <p style="text-align:left">void setAttribute(String attribute, Object value)：设置Session属性。value参数可以为任何Java Object。通常为Java Bean。value信息不宜过大</p>
            <p style="text-align:left">String getAttribute(String attribute)：返回Session属性</p>
            <p style="text-align:left">Enumeration getAttributeNames()：返回Session中存在的属性名</p>
			  <p style="text-align:left">void removeAttribute(String attribute)：移除Session属性</p>
        </section>

        <section>
           
            <p style="text-align:left">String getId()：返回Session的ID。该ID由服务器自动创建，不会重复。可以尝试在cookie中保存session.getId()，其保存的值和自动创建的JSESSIONID相同</p>
            <p style="text-align:left">long getCreationTime()：返回Session的创建日期。返回类型为long，常被转化为Date类型，例如：Date createTime = new Date(session.get CreationTime())</p>
            <p style="text-align:left">long getLastAccessedTime()：返回Session的最后活跃时间。返回类型为long</p>
			<p style="text-align:left">int getMaxInactiveInterval()：返回Session的超时时间。单位为秒。超过该时间没有访问，服务器认为该Session失效</p>
			
        </section>
        <section>
		<p style="text-align:left">void setMaxInactiveInterval(int second)：设置Session的超时时间。单位为秒</p>
            <p style="text-align:left">boolean isNew()：返回该Session是否是新创建的，此新创建的标准就是有没有访问过web容器</p>
            <p style="text-align:left">void invalidate()：void invalidate()</p>
            <p style="text-align:left">由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。</p>
            <p style="text-align:left"></p>
        </section>
		 <section>
            <p style="text-align:left">Tomcat中Session的默认超时时间为20分钟。通过setMaxInactiveInterval(int seconds)修改超时时间。可以修改web.xml改变Session的默认超时时间。例如修改为60分钟，此方式会使得所有session都被设置为60，而setMaxInactiveInterval则是修改单独一个session：</p>
            <p style="text-align:left">《session-config》</p>
             <p style="text-align:left">《session-timeout》60《/session-timeout》     《！-- 单位：分钟 --》</p>
              <p style="text-align:left">《/session-config》</p>
        </section>

        <section>
            <h3>3.常见问题</h3>
        </section>

        <section>
            <p style="text-align:left">Cookie和Session的联系和区别？</p>
            <p style="text-align:left">如果浏览器禁用cookie后怎么办？</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>


        <section>
            <h3>4.解决方案</h3>
        </section>

        <section>
            <p style="text-align:left">联系：</p>
            <p style="text-align:left">虽然Session保存在服务器，对客户端是不透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session 需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一 个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session 依据该Cookie来识别是否为同一用户。当第二次发起请求的时候就依靠此SessionID来在服务器中寻求匹配的session（前提是服务器将session信息序列化保存起来了）</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>
       <section>
            <p style="text-align:left">该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。</p>
            <p style="text-align:left">因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享父窗口的Cookie，因此会共享一个Session。</p>
            <p style="text-align:left">注意：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的Session。</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>

        <section>
            <p style="text-align:left">区别：</p>
            <p style="text-align:left">Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。</p>
            <p style="text-align:left">cookie因为是存在客户端，发送给服务器的时候就会存在被中间人劫持的风险，所以在安全上会逊于session。而且操作上也比session复杂</p>
            <p style="text-align:left">但是都放在session上的后果就是服务器上内存飙升，线程多了还会影响响应速度</p>
            <p style="text-align:left"></p>
        </section>

       <section>
            <p style="text-align:left">解决禁用cookie:</p>
            <p style="text-align:left">由于cookie可以被人为的禁止，必须有其它的机制以便在cookie被禁止时仍然能够把session id传递回服务器，经常采用的一种技术叫做URL重写，
就是把session id附加在URL路径的后面，附加的方式也有两种，一种是作为URL路径的附加信息，另一种是作为查询字符串附加在URL后面。
网络在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。缺点就是网页中不能有静态页面，否则就无法完成重写</p>
            <p style="text-align:left">还有一种方法是作为隐藏表单的形式携带sessionid，可以将两者理解为get和post的区别，此方法的缺点是仅当每个页面都是有表单提交而动态生成时，才能使用这种方法。</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>
		  <section>
            <p style="text-align:left">注意：</p>
            <p style="text-align:left">TOMCAT判断客户端浏览器是否支持Cookie的依据是请求中是否含有Cookie。尽管客户端可能会支持Cookie，但是由于第一次请求时不会携带任何Cookie（因为并无任何Cookie可以携带），URL地址重写后的地址中仍然会带有jsessionid。当第二次访问时服务器已经在浏览器中写入Cookie了，因此URL地址重写后的地址中就不会带有jsessionid了。</p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
            <p style="text-align:left"></p>
        </section>
        
        <section>
            <h3>5.编码实战</h3>
        </section>

        <section>
            <h3>6.扩展思考</h3>
        </section>

        <section>
            <p style="text-align:left">session和cookie的应用场景</p>
        </section>

        <section>
            <p style="text-align:left">session:</p>
			 <p style="text-align:left">除非是纯静态的页面，否则都会用到session来记录用户的行为。</p>
             <p style="text-align:left">cookie典型应用场景:</p>
			 <p style="text-align:left">1.判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p>
            <p style="text-align:left">2.另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</p>
            <p style="text-align:left"></p>
        </section>



        <section>
            <h3>7.参考文献</h3>
        </section>

        <section>
            <p>https://blog.csdn.net/duan1078774504/article/details/51912868</p>
            <p></p>
            <p></p>
        </section>

        <section>
            <h3>8.更多讨论</h3>
        </section>

        <section>
            <h4>Thanks</h4>
            <p></p>
            <p><small>By : 上海分院 王琦超</small></p>
        </section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
