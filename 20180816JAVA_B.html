
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h3>REST简单了解</h3>
			<p></p>
            <h4></h4>
            <p>分享人：郑志航</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>



         <section> 
            <h3>1.背景介绍</h3>
            <h5>REST</h5>
            <p style="text-align:left">REST的全称是Represetational State Transfer，中文意思是：表述性状态转移；
</p>
            <p style="text-align:left">是一个：符合架构原理的前提下，理解和评估以网络为基础的应用软件架构设计，得到一个功能性强，性能好，适宜通信的架构。REST指的是一组架构约束条件和原则；
</p>
           <p style="text-align:left">如果一个架构符合REST的约束条件和         原则，我们就称它为RESTful架构。
</p>
        </section>

          <section> 
            <h3>1.背景介绍</h3>
            <h5>REST</h5>
            <p style="text-align:left">REST 本身没有创造新的技术，组件或者服务，只是使用web的现有特征和能力，更好地使用现有Web标准中的一些准则和约束。</p>
            <p style="text-align:left">REST本身受Web影响很深，但是理论上REST架构风格并不是绑定在HTTP上的，只不过HTTP是唯一与REST相关的实例；</p>
        </section>



        <section>
            <h3>.2知识剖析</h3>
            <h5>理解RESTful</h5>
            <p style="text-align:left">围绕资源展开讨论，从资源的定义，获取，表述，关联，状态变迁的角度，列举一些关键概念加以解释。</p> 
        </section>

         <section>
            <h3>.2知识剖析：理解RESTful</h3>
            <h5>内容大纲：</h5>
            <p style="text-align:left">2.1资源与URI</p> 
            <p style="text-align:left">2.2统一资源接口</p> 
            <p style="text-align:left">2.3资源的表述</p> 
            <p style="text-align:left">2.4资源的链接</p> 
            <p style="text-align:left">2.5状态的转移</p> 
        </section>

        <section>
            <h3>.2知识剖析</h3>
            <h5>2.1.1:资源与URI</h5>
            <p style="text-align:left">*REST是指：表述性状态转移， 表述，就是指代资源；</p> 
            <p style="text-align:left">*任何事物，只要被引用到的必要，它就是一个资源，资源可以是实体（电话，信息），也可以是概念（依赖关系，价值）；</p> 
            <p style="text-align:left">*需要让表述（资源）可以被识别，需要有个唯一标识URI（Uniform Resource Identifier）；</p> 
            <p style="text-align:left">*URI可以看成是资源的地址，也可以看成是资源的名称；如果，一些信息不能用URI来表示，那么它就不能算是一个资源，只能算是资源的一些信息而已；</p> 
        </section> 

        <section>
            <h3>.2知识剖析</h3>
            <h5>2.1.2:URI的设计/h5>
            <p style="text-align:left">*URI的设计，应该遵循可寻址原则，具有自描述性，需要在形式上给人直觉上的关联；</p> 
            <p style="text-align:left">如： http://localhost:8081/student/1?id=1&name=%E8%80%81%E4%B8%80&age=18</p> 
            <p style="text-align:left">网址本地，查找对象是Student，序号是1，id为1；</p> 
            <p style="text-align:left">如http://www.oschina.net/news/38119/oschina-translate-reward-plan。</p> 

        </section> 

        <section>
            <h3>.2知识剖析</h3>
            <h5>2.1.2:URI的设计</h5>
            <p style="text-align:left">在设计的时候，有几个标识符需要注意：</p> 
            <p style="text-align:left">-*使用/来表示资源的层级关系</p> 
            <p style="text-align:left">-*使用？用来过来资源</p> 
            <p style="text-align:left">“？”可以用来当作参数的传递，也可以用于对资源的过滤；</p> 
            <p style="text-align:left">“，”或 “；”可以用来表示同级资源的关系</p> 
            <p style="text-align:left">/git/git /block-sha1/sha1.h/compare/step1;step4.</p> 
        </section> 

        <section>
            <h3>.2知识剖析</h3>
            <h5>2.1.2:URI的设计</h5>
            <p style="text-align:left">不过现在更多是使用…来做这个事情：</p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p>           
        </section>

         <section>
            <h3>.2知识剖析</h3>
            <h5>2.1.2:URI的设计</h5>
            <p style="text-align:left">不过现在更多是使用…来做这个事情：</p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p>           
        </section>

        <section>
            <h3>.2知识剖析</h3>
            <h5>2.1.2:URI的设计</h5>
            <p style="text-align:left">不过现在更多是使用…来做这个事情：</p> 
			<p style="text-align:left">例如 /git/git /block-sha1/sha1.h/compare/step1…next;</p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p>           
        </section>

         <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口</h5>
            <p style="text-align:left">RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问</p> 
			<p style="text-align:left">标准的HTTP方法有：GET，HEAD，PUT，DELETE。</p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p> 
			<p style="text-align:left"></p>           
        </section>

          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:GET</h5>
            <p style="text-align:left">安全且幂等;获取表示;变更时获取表示（缓存）</p> 
			<p style="text-align:left">200（OK） - 表示已在响应中发出</p> 
			<p style="text-align:left">204（无内容） - 资源有空表示</p> 
			<p style="text-align:left">301（Moved Permanently） - 资源的URI已被更新</p> 
			<p style="text-align:left">303（See Other） - 其他（如，负载均衡）</p> 
			<p style="text-align:left">304（not modified）- 资源未更改（缓存）</p>           
        </section>       

          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:GET</h5>
            <p style="text-align:left">安全且幂等;获取表示;变更时获取表示（缓存）</p> 
			<p style="text-align:left">400 （bad request）- 指代坏请求（如，参数错误）</p> 
			<p style="text-align:left">404 （not found）- 资源不存在</p> 
			<p style="text-align:left">406 （not acceptable）- 服务端不支持所需表示</p> 
			<p style="text-align:left">500 （internal server error）- 通用错误响应</p> 
			<p style="text-align:left">503 （Service Unavailable）- 服务端当前无法处理请求</p>           
        </section>       

          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:POST</h5>
            <p style="text-align:left">不安全且不幂等</p> 
            <p style="text-align:left">使用服务端管理的（自动产生）的实例号创建资源</p> 
            <p style="text-align:left">创建子资源</p> 
            <p style="text-align:left">部分更新资源</p> 
            <p style="text-align:left">如果没有被修改，则不过更新资源（乐观锁）</p> 
        </section>  

         <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:POST</h5>
            <p style="text-align:left">200（OK）- 如果现有资源已被更改</p> 
            <p style="text-align:left">201（created）- 如果新资源被创建</p> 
            <p style="text-align:left">202（accepted）- 已接受处理请求但尚未完成（异步处理）</p> 
            <p style="text-align:left">301（Moved Permanently）- 资源的URI被更新</p> 
            <p style="text-align:left">303（See Other）- 其他（如，负载均衡）</p> 
            <p style="text-align:left">400（bad request）- 指代坏请求</p> 
        </section> 
 
         <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:POST</h5>
            <p style="text-align:left">404 （not found）- 资源不存在</p> 
            <p style="text-align:left">406 （not acceptable）- 服务端不支持所需表示</p> 
            <p style="text-align:left">409 （conflict）- 通用冲突</p> 
            <p style="text-align:left">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</p> 
            <p style="text-align:left">415 （unsupported media type）- 接受到的表示不受支持</p> 
            <p style="text-align:left">500 （internal server error）- 通用错误响应</p> 
            <p style="text-align:left">503 （Service Unavailable）- 服务当前无法处理请求</p> 
        </section>    

           <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:</h5>
            <p style="text-align:left"></p> 
            <p style="text-align:left"></p> 
            <p style="text-align:left"></p> 
            <p style="text-align:left"></p> 
            <p style="text-align:left"></p> 
            <p style="text-align:left"></p> 
        </section> 
        
          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:PUT</h5>
            <p style="text-align:left">不安全但幂等</p> 
            <p style="text-align:left">用客户端管理的实例号创建一个资源</p> 
            <p style="text-align:left">通过替换的方式更新资源</p> 
            <p style="text-align:left">如果未被修改，则更新资源（乐观锁）</p> 
            <p style="text-align:left">200 （OK）- 如果已存在资源被更改</p> 
            <p style="text-align:left">201 （created）- 如果新资源被创建</p> 
        </section> 
          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:PUT</h5>
            <p style="text-align:left">301（Moved Permanently）- 资源的URI已更改</p> 
            <p style="text-align:left">303 （See Other）- 其他（如，负载均衡）</p> 
            <p style="text-align:left">400 （bad request）- 指代坏请求</p> 
            <p style="text-align:left">404 （not found）- 资源不存在</p> 
            <p style="text-align:left">406 （not acceptable）- 服务端不支持所需表示</p> 
            <p style="text-align:left">409 （conflict）- 通用冲突</p> 
        </section> 

         <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:PUT</h5>
            <p style="text-align:left">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</p> 
            <p style="text-align:left">415 （unsupported media type）- 接受到的表示不受支持</p> 
            <p style="text-align:left">500 （internal server error）- 通用错误响应</p> 
            <p style="text-align:left">503 （Service Unavailable）- 服务当前无法处理请求</p> 
        </section> 

          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:DELETE</h5>
            <p style="text-align:left">不安全但幂等</p> 
            <p style="text-align:left">删除资源</p> 
            <p style="text-align:left">200 （OK）- 资源已被删除</p> 
            <p style="text-align:left">301 （Moved Permanently）- 资源的URI已更改</p> 
            <p style="text-align:left">303 （See Other）- 其他，如负载均衡</p> 
            <p style="text-align:left">400 （bad request）- 指代坏请求</p> 
        </section> 

          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.2:统一资源接口:DELETE</h5>
            <p style="text-align:left">404 （not found）- 资源不存在</p> 
            <p style="text-align:left">409 （conflict）- 通用冲突</p> 
            <p style="text-align:left">500 （internal server error）- 通用错误响应</p> 
            <p style="text-align:left">503 （Service Unavailable）- 服务端当前无法处理请求</p> 
        </section> 

          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.3资源的表述</h5>
            <p style="text-align:left">客户通过HTTP方法可以获取资源？确切的说，客户端获取的知识资源的表述而已。</p> 
            <p style="text-align:left">资源在外界的具体呈现，可以有多种表述。在客户端和服务端之间传送的，也只是资源的表诉，而不是资源本身。</p> 
            <p style="text-align:left">Eg:文本资源可以采用HTML，XML，JSON等格式，图片可以使用PNG或JPG展现出来。</p> 
            <p style="text-align:left">表述可以包括 数据+描述数据等元数据。 如：HTTP头的“Content-Type”就是这样一个元数据。</p> 
            <p style="text-align:left">客户端可以通过Accept头，请求一种特定格式的表诉，</p> 
            <p style="text-align:left">服务端则通过Content-Type告诉客户端资源的表诉形式。</p> 
        </section> 


          <section>
            <h3>.2知识剖析</h3>
            <h5>-2.3资源的表述</h5>
            <p style="text-align:left">在URI里边带上版本号</p> 
            <p style="text-align:left">如果版本号理解成资源的不同表述，那么所有版本应该只用一个URL，并通过Accept头部来区分。</p> 
            <p style="text-align:left">Eg:</p> 
            <p style="text-align:left">Accept: vnd.example-com.foo+json; version=1.0</p> 
            <p style="text-align:left">Accept: vnd.example-com.foo+json; version=1.2</p> 
            <p style="text-align:left">Accept: vnd.example-com.foo+json; version=2.0</p> 
        </section> 

        <section>
            <h3>.2知识剖析</h3>
            <h5>-2.3资源的表述</h5>
            <p style="text-align:left">如果版本号理解成不同的资源的话，那么一个版本就对应一个URL：</p> 
            <p style="text-align:left">http://api.example.com/1.0/foo</p> 
            <p style="text-align:left">http://api.example.com/1.2/foo</p> 
            <p style="text-align:left">http://api.example.com/2.0/foo</p> 
        </section> 



        <section>
        <h3>.2知识剖析</h3>
            <h5>-2.4资源的连接</h5>
            <p style="text-align:left">REST是使用标准的HTTP方法来操作资源的，但是不单单是CURD的Web数据库架构。</p> 
            <p style="text-align:left">核心的概念是： 超媒体即应用状态引擎（hypermedia as the engine of application state)</p> 
            <p style="text-align:left">超媒体是：</p> 
            <p style="text-align:left">A page  -- B page -- C page---</p> 
            <p style="text-align:left">利用来超媒体的概念： 把一个个资源连接起来；</p>   	
        </section>

        <section>
        <h3>.2知识剖析</h3>
            <h5>-2.4资源的连接</h5>
            <p style="text-align:left">所以需要在表诉格式里边，加入连接来引导客户端；</p> 
            <p style="text-align:left">例如下面这个例子，创建订单后通过链接引导客户端如何去付款。</p> 
            <p style="text-align:left">很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。</p> 
            <p style="text-align:left">时间来给资源的表述提供链接，而不是专注于"资源的CRUD"。</p> 
        </section>

        <section>
        <h3>.2知识剖析</h3>
            <h5>2.5:状态的转移</h5>
            <p style="text-align:left">无状态通信原则，不是说客户端应用不能有状态，</p> 
            <p style="text-align:left">而是指服务端不应该保存客户端状态；</p> 
            <p style="text-align:left"></p> 
            <p style="text-align:left"></p> 
            <p style="text-align:left"></p>   	
        </section>


         <section>
        <h3>.2知识剖析</h3>
            <h5>2.5.1应用状态与资源状态</h5>
            <p style="text-align:left">状态： 应用状态，资源状态；</p> 
            <p style="text-align:left">客户端负责维护应用状态，服务端维护资源状态。</p> 
            <p style="text-align:left">客户端与服务端的交互必须是无状态的，并在每一次请求中，包含处理该请求所需的一切信息；</p> 
            <p style="text-align:left">服务端不需要在请求见保留应用状态，只有在接收到实际请求的时候，服务端才会关注应用状态；</p> 
            <p style="text-align:left"></p>   	
        </section>       

         <section>
        <h3>.2知识剖析</h3>
            <h5>2.5.1应用状态与资源状态</h5>
            <p style="text-align:left">这种无状态通信原则，使得服务端和中介能够理解独立的请求和相应；</p> 
            <p style="text-align:left">在多次请求中，同一客户端也不需要依赖于同一服务器，方便实现高扩展和高可用行的服务端；</p> 
            <p style="text-align:left">但是：</p> 
            <p style="text-align:left">利用Cookie跟踪某个服务端会话状态，就违反无状态通信原则设计，意味着每次发出去的Cookie是用于被构建会话状态的；</p> 
            <p style="text-align:left">不过：对于保存的是一些服务器不依赖于绘画状态既可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。
</p>   	
        </section>    


         <section>
        <h3>.2知识剖析</h3>
            <h5>2.5.2 应用状态转移：</h5>
            <p style="text-align:left">“会话”状态不是作为资源状态，保存在服务器的，而是被客户端作为应用状态进行跟踪的；</p> 
            <p style="text-align:left">客户端应用状态在服务端提供的超媒体的指引下发生变迁；服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入；</p> 
            <p style="text-align:left">类似“下一页”之类的连接起的就是这种推进状态的作用---指引你如何从当前状态进入下一个可能的状态；</p> 
        </section>    





        <section>
            <h3>3.常见问题</h3>
            <p style="text-align:left">-1:POST和PUT用于创建资源的区别： </p> 
            <p style="text-align:left">-2:客户端不一定都支持这些HTTP方法吧? </p> 
            <p style="text-align:left">-3:统一资源接口对URI有什么指导意义? </p> 
            <p style="text-align:left">-4:统一接口是否意味着不能扩展带特殊语意的方法？ </p> 
        </section>


        
		
        <section>
            <h3>4.解决方案</h3>
            <h4>-1:POST和PUT用于创建资源的区别：</h4>
            <p style="text-align:left">这个连接说的很好：
https://blog.csdn.net/yangruibao/article/details/7898788 </p>
            <p style="text-align:left">POST不是幂等的，PUT是幂等的。 </p>
            <p style="text-align:left">例子： </p>
            <p style="text-align:left">比如：http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。 </p> 
            <p style="text-align:left">如果REST这个服务是幂等的，那么多次请求，后一个请求会把之前的内容覆盖掉也就是说是PUT请求；如果多次请求，产生了多个博客帖子，那么就是POST，因为产生了副作用，就不再是幂等的了； </p>            
        </section>


        <section>
            <h3>4.解决方案</h3>
            <h4>-1:POST和PUT用于创建资源的区别：</h4>
            <p style="text-align:left">这个连接说的很好：
https://blog.csdn.net/yangruibao/article/details/7898788 </p>
            <p style="text-align:left">POST不是幂等的，PUT是幂等的。 </p>
            <p style="text-align:left">例子： </p>
            <p style="text-align:left">比如：http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。 </p> 
            <p style="text-align:left">如果REST这个服务是幂等的，那么多次请求，后一个请求会把之前的内容覆盖掉也就是说是PUT请求；如果多次请求，产生了多个博客帖子，那么就是POST，因为产生了副作用，就不再是幂等的了； </p>      
        </section>

         <section>
            <h3>4.解决方案</h3>
            <h4>-4.2:客户端不一定都支持这些HTTP方法吧?</h4>
			<p>对于一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法；
实践上，客户端和服务端都可能需要做一些妥协；
如：ralis框架支持通过隐藏参数_method=DELETE来传递真实的请求方法；
       Backbone这样的客户端，MVC框架则允许传递_method传输和设置X-HTTP-Method-Override
       头来规避这个问题。</p>
        </section> 

         <section>
            <h3>4.解决方案</h3>
            <h4>--4.3:统一资源接口对URI有什么指导意义?</h4>
			<p>统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作：</p>
        </section> 

         <section>
            <h3>4.解决方案</h3>
            <h4>-4.4:统一接口是否意味着不能扩展带特殊语意的方法？</h4>
			<p>统一接口并不阻止扩展方法， 只要方法对资源的操作有具体的，可识别的语意就可，并能够保持整个接口的统一性。</p>
        </section> 





       
        <section>
            <h3>5.编码实战</h3>
        </section>

		 <section>
            <h3>6.扩展思考</h3>
            <p style="text-align:left">Tocken</p>
        </section>

        <section>
            <h3>7.参考文献</h3>
			<p style="text-align:center">百度，CSDN博客</p>
        </section>
		
        <section>
            <h3>8.更多讨论</h3>
            <p>今天的分享就到这里啦，欢迎大家提问和探讨!</p>
        </section>
    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>