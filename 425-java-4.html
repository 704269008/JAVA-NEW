<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="./css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="./css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="./lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="./img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>为什么要使用Tiles框架</h2>
            <p></p>
            <h3>java分享会</h3>
            <p>分享人：袁磊</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.编码实战</p>
            <p>4.常见问题</p>
            <p>5.参考文献</p>
            <p>6.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>

		<section>

            <h3>Tiles框架</h3>
            <p>Tiles是一种JSP布局框架，主要目的是为了将复杂的jsp页面作为一个的页面的部分机能，然后用来组合成一个最终表示用页面用的，这样的话，便于对页面的各个机能的变更及维护。Tiles使得struts在页面的处理方面多了一种选择。并且更容易实现代码的重用。</p>
            <p>最早的Tiles是组装在Struts1.1里面的（Struts-Tiles），后面发展为独立的Tiles框架（Tiles 2+，目前最新版本为3.0）。</p>
          
        </section>
       
        <section>
        <h3>Tiles页面布局</h3>
        <p>Tiles增加了layout的概念，其实就是把一个页面划分为几块。通常的来说一个页面大概可以划分为如下几块：</p>
        <p>head页面头部：存放一个运用的公共信息：logo等，如果是网站可能是最上面的一块。</p>
        menu页面菜单：放置一个运用中需要使用的菜单，或者在每一个页面都使用的连接。footer页面尾部：如版权信息等。body页面主题内容：每个页面相对独立的内容。
        <p>如果按上面的划分那对每一个页面我们只要写body里面的内容，其他的就可以共享重用。如果大多数页面的布局基本相同我们甚至可以使用一个jsp文件根据不同的参数调用不同的body。</p>
        </section>

        <section>
            <h3>2.知识剖析</h3>
        </section>

        <section>
            <h3>Tiles框架</h3>
            <p>Tiles框架可以令我们组合可以复用的Tiles来搭建网页。例如，下图中的页面就是通过组合一个header, 一个footer, 一个menu 和一个body搭建起来的。</p>
            <p>每一个Tiles（header, menu, body, ...）都是一个JSP页面，它们也可以通过组合其他的Tiles来搭建。</p>
            <p>应用Tiles就好比是应用Java的方法：需要你定义Tiles（方法体），然后你才能够在任何你需要的地方“调用”该方法体，并传递一些参数。在Tiles中，为了避免与request参数相混淆，参数
            （parameters）被称为属性（attributes）。</p>
            </section>
            
         <section>
               <p>Tiles的方法体（也可以说是内容——译者注）可以是一个简单的JSP页面， 或者是一个Struts的动作（action），或者任何一个指向现存的网页资源的URI。</p>
               <p>插入或者调用Tiles可以通过在JSP中的任何位置置入如下tag来完成：tiles:insert ...。插入也可以通过下面的方法来完成：指定一个作为Struts forward的路径的自定义名；或者指定一个作为Struts action的input，forward或者include属性的自定义名。</p> 
               <p>Tiles的方法体是用来创建版面布局，可复用部分等的,而Tiles的插入操作是用来插入Tiles的.同一个Tiles可以在同一个站点甚至同一个页面被重用多次。</p>
        </section>

        <section>
           <p>Tiles的插入可以与一个在Tiles中称作“definition”的逻辑名联系起来。一个Tiles的definition包含一个逻辑名，一个主体页面和一些属性值。definition的声明并不插入与其相关联的Tiles方法体，它只是让Tiles与它的逻辑名关联起来。可以在任何能够插入Tiles地方运用定义的逻辑名，这样与其对应的Tiles及其属性就被插入进来了。</p> 
           <p>Tiles的definition的定义可以在JSP页面中进行，也可以在一个或者多个中心控制文件中进行。
           Definition可以继承于另外一个Tiles的definition，重载一些属性，添加一些新的属性等等。这就允许“父类”的definition定义一些通用的layout, header, menu, footer. 所有其他继承于该父类的
            definition可以简单地通过改变其definition来改变整个页面。</p>
        </section>

        <section>
        	<h3>嵌套tiles</h3>
        	<p>一个 tile 布局可以插入到另一个 tile 布局中，依此类推。实际上，创建的 tile 布局如此之
        	小，以至于它们本身并不是真正的模板。相反，它们是更类似于自定义标签的小型可视组件，而不是页面模板。</p>
        </section>
        
       <section>
       	    <h3>Tiles运行流程</h3>
       	    <p>当Spring MVC的DispatchServlet收到来自浏览器的请求后，分析出需要请求的控制器，然后访问解析出来的控制器StudentController的home方法，接着就开始解析视图了。因为我们用的是Tiles的视图解析器，激情饱满的二级制代码就访问到了layout.xml
       	    (jnshu.xml),最后根据layout.xml的配置组装成我们看到的页面。</p>
       </section>

       <section>
       	<p>为什么要用Tiles框架</p>
       	<p>举个通俗的例子,现在，假如有一个超级大的电子商务网站，网站拥有10万个JSP页面（悄悄告诉你，这仅仅是一个假设），并且每个JSP都引用了同一个JSP（我们称这个JSP页面为A吧）。现在你就是这个网站的开发人员，有一天老板跑到你面前说：“大量用户反馈页面A设计得太丑，严重影响用户体验，所以你今天必须要让页面A从网站上消失，否则炒鱿鱼走人”，这个凶神恶霸的老板说完就甩手走出去了，你没有任何辩解的机会。这时，恐怕你不会觉得自己一人能够搞定，那怎么办？程序员都有很多好基友，找一百个基友来一起改，每人只需要改1000个页面。不然，只有垂头丧气地收拾好东西离职了。</p>
       </section>
       <section>
        <p>但是，要是有一天老板又跑过来找你，让你为每个JSP页面的底部加一个跳舞的小黄人，又该怎么办呢？那有没有一种方法，可以不用请一百个好基友帮忙，就可以在十分钟之内完成老板交给你的任务？没错，Tiles就是为你遇到的这种需求服务的。一旦你在网站系统中使用了Tiles技术，若老板让你删除10万个页面所引用的一个JSP，如果你的速度快的话，你可以在10秒钟之内解决。那要想再让这10万个页面去引用一个JSP呢？也是一样的操作，非常简单。</p>
       </section>
        <section>
            <h3>3.编码实战</h3>
        </section>

        <section>
            <h3>4.常见问题</h3>
        </section>


        <section>
           1,在使用Tile框架中要注意导入Tiles的jar包冲突问题.
        </section>

       
       
        <section>
            <h3>5.参考文献</h3>
            <p>
              https://blog.csdn.net/zaowei21/article/details/215077
            </p>
            <p>
                https://blog.csdn.net/chj225500/article/details/7055526
            </p>
            <p>
              http://mengyang.iteye.com/blog/1156733
            </p>
           
        </section>

        <section>
            <h3>6.更多讨论</h3>
            <p></p>
        </section>

        <section>
            <h4>鸣谢</h4>
            <p>感谢观看,如有出错,恳请指正</p>
           
        </section>

    </div>
<script src="./lib/reveal/js/head.min.js"></script>
<script src="./lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: './plugin/markdown/marked.js' },
            { src: './plugin/markdown/markdown.js' },
            { src: './plugin/notes/notes.js', async: true },
            { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>

