
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>什么是压测，为什么要进行压力测试？JMeter工具的使用</h2>
			<p></p>
            <h3>java小课堂</h3>
            <p>分享人：杨棋</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
        <section>
            <p>性能测试是通过自动化的测试工具模拟多种正常峰值和异常负载条件来对系统的各项性能指标进行测试。
                性能测试包括，负载测试，强度测试，容量测试</p>
			<p>通过负载测试,确定在各种工作负载下系统的性能,目标是当负载逐渐增加时,测试系统各项性能指标的变
                化的情况.</p>
            <p>压力测试是通过确定一个系统的瓶颈或者不能接受的性能点,来获得系统能提供的最大服务级别的测试.
            </p>
            <p>在Web性能测试领域,有两种工具广泛使用:LoadRunner和JMeter.
            </p>
        </section>
<!--        <section>
            <p>Resin特点</p>
            <p>1、Resin包含了很多可靠的特性，包括服务器自动重启、检测并重启死锁的服务器、管理JVM内存以防止内存泄露等。</p>
            <p>2、Resin可以将多个服务器作为一个服务器来对客户进行响应，从而增强服务器的扩展能力。</p>
            <p>3、Resin可实现持久和分布的sessions：持久的session能够在服务器重启的时候保持现有的Http会话，分布式的session可以在多个服务器之间共享Http会话的状态。</p>
        </section>
        <section>
            <p>Jetty服务器</p>
            <p>Jetty 是一个开源的servlet容器，它为基于Java的web内容，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。</p>
        </section>
        <section>
            <p>Jetty特点</p>
            <p>1、Jetty的指导原则是“简单不复杂“。Jetty容易理解和使用：  通过API或者XML文件配置；  XML文件语法直接了当地在POJOs上影射API操作；  默认的配置文件可以使Jetty作为外盒（out-of-the-box）；  只需少量的行数就可以嵌入一个Jetty实例。</p>
            <p>2、可扩展性在异步的WEB2.0类型的应用程序使用的技术，例如AJAX，连接停留时间要比处理一个静态页长，线程和内存需求可能急剧增长。
                底层必须优雅地处理这些问题，一个低速的数据库连接可能造成站点瘫痪，因为线程被占满了。使用Jetty...</p>
        </section>
        <section>
            <p>3、高效大量的努力用来优化代码，精炼的代码以至于漏洞尽可能少：相关性尽可能少； 核心保持最小，附加函数放在可选包中;可扩展性是一个关键问题;高强度下性能衰减平缓。</p>
            <p>4、嵌入性 Jetty是一个非常好的组件。这意味着很容易嵌入到一个应用程序中，而不需要应用程序去适应它： 使用依赖注射和反转的控制模式</p>
            <p>5、Jetty内建插入性。所有Jetty核心组件的实现允许不同的选择，至少一个或者更多，组件的实现总是会提供的。如果这些仍然不能满足你的要求，你可以自由的编写底层接口和抽象类最为基础。这意味着Jetty能够容易地用在一个特别的应用环境中。当Jetty在一个 JavaEE服务器中作为web容器时，这是相当有用的，Jetty的插入性保证了它和主机容器的一个紧密的集成。</p>
        </section>-->
	
        <section>
            <h3>2.知识剖析</h3>
        </section>
        <section>
				<p>1.性能测试的目的</p>
				<p>性能测试的目的是验证软件系统能否达到用户提出的性能指标,同时发现软件系统中存在的性能瓶颈,
                    以优化软件,最后起到优化系统的目的.包括以下结构方面:
                </p>
		</section>
        <section>
            <p>评估系统的能力;</p>
            <p>识别系统中的弱点;</p>
            <p>系统调优;</p>
            <p>测试软件中的问题;</p>
            <p>验证稳定性(Resilience)和可靠性(Reliability);</p>
            <p></p>
        </section>
        <section class="present" style="top: 0px; display: block;">
            <p style="text-align:center"><b>2.性能测试的常见指标</b></p>
            <p style="text-align:left">对于B/S架构,一般关注Web服务器性能指标:
            </p><ul>
            <li>avg rps:平均每秒钟的响应次数=总次数/秒数</li>
            <li>avg time to last byte per terstion(mstes):平均每秒业务脚本的迭代次数</li>
            <li>successful rounds:成功的请求</li>
            <li>failed rounds:失败的请求</li>
            <li>successful hits:成功的点击次数</li>
            <li>failed hits:失败的点击次数</li>
            <li>hits per second:每秒点击次数</li>
            <li>successful hits per second:每秒成功的点击次数</li>
            <li>failed hits per second:每秒失败的点击次数</li>
            <li>attempted connections:尝试连接数</li>
            <li>throughput:吞吐率</li>
        </ul>
            <p></p>
        </section>
        <section class="present" style="top: 4px; display: block;">
            <p style="text-align:center"><b>3.JMeter常用测试单元</b></p>
            <p>
            </p><ol>
            <li>线程组,所有测试计划的起点,所有的逻辑控制器和采样器都必须放在线程组之下.常用参数:</li>
            <ul>
                <li>设置线程数量(Numbers of Threads)</li>
                <li>设置线程启动周期(Ramp-Up Period)</li>
                <li>设置执行测试脚本的循环次数(Loop Count)</li>
            </ul>
            <li>控制器</li>
            <ul>
                <li>采样器,被JMeter用来向服务器发送请求,并等待响应;</li>
                <li>逻辑控制器,控制JMeter的测试逻辑,特别是何时发送请求.</li>
            </ul>
            <li>监听器,提供了对JMeter在测试期间收集到的信息的访问方法.</li>
            <ol>
                <p></p>
            </ol></ol></section>
        <section class="present" style="top: 66px; display: block;">
            <p style="text-align:left">4.定时器,默认情况下,线程在发送请求之间没有间隔,添加一种定时器,以便设定请求之间间隔多长时间.
            </p>
            <p style="text-align:left">5.断言,检查从服务器获取的响应内容.
            </p>
            <p style="text-align:left">6.Sample与采样器紧密相连,不发送请求,可以添加或者修改请求.
            </p>
            <p style="text-align:left">7.前置处理器,在采样器发出请求之前做一些特殊操作.
            </p>
            <p style="text-align:left">8.后置处理器,在采样器发出请求之后做一些特殊操作,常用来从响应中提取数据.
            </p>
        </section>
        <section class="present" style="top: 188px; display: block;">
            <p style="text-align:center"><b>4.JMeter执行顺序规则</b>
            </p><p style="text-align:left">配置元件----前置处理器----定时器----采样器----
            后置处理器(除非服务器响应为空)-----断言(除非服务器响应为空)----监听器(除非服务器响应为空)
        </p>
        </section>
        <section class="present" style="top: 4px; display: block;">
            <p style="text-align:center"><b>5.JMeter测试结果</b>
            </p><ul>
            <li>label:定义HTTP请求名称</li>
            <li>samples:表示这次测试中一共发出了多少个请求</li>
            <li>average:平均响应时长,默认情况下是单个request的平均响应时长</li>
            <li>median:中位数,50%用户的响应时长(50%阈值)</li>
            <li>90%line:90%用户的响应时长(90%阈值)</li>
            <li>min:访问页面的最小响应时长</li>
            <li>max:访问页面的最大响应时长</li>
            <li>error%:错误请求数量/请求总数</li>
            <li>throughput:默认情况下表示每秒完成的请求数</li>
            <li>KB/sec:每秒从服务器接收到的数据量</li>
        </ul>
            <p></p>
        </section>


         <section>
            <h3>3.常见问题</h3>
        </section>
        <section>
            <p>请求数据中有乱码!</p>
        </section>
        <!--
		<section>
            <p>2.时区</p>
            <p>精度,将java.util.Date转为java.sql.Date时候，日期的时分秒
                会被去掉，数据的精度发生变化了。这是两个上下级类之间
                很不合理的问题。 而JDBC中定义接口时候，用的是
                java.sql.Date，而我们常常用到的Date都是java.util.Date，这
                往往导致一些转换过程中发生误差。
                java.sql.Timestamp类，它保持了日期数据原有的精度。可以
                实现和java.util.Date的无损转换。但是Timestamp这个类在一
                些预定义SQL中常常会出问题，</p>
        </section>
        <section>
            <p>3.java.sql.Date，在JDBC接口中使用了，如果对其进行修改，
                JDBC接口规范也要改，那么将引发各个数据库厂商对数据库
                驱动也要改，这是不可接受的。[1]</p>
            </section>
		-->
        
        <section>
            <h3>4.解决方案</h3>
        </section>
        <section>
            <p>设置HTTP请求，参数中的值显示为中文，但系统接受数据时，中文显示为乱码；在“查看结果树”中，查看HTTP请求，请求参数中的中文数据显示乱码。</p>
            <p>在HTTP请求页面，Content encoding设置为utf-8即可。</p>
        </section>
        <section>
            <h3>5.编码实战</h3>
        </section>
        <section>
            <h3>6.扩展思考</h3>
        </section>
        <section class="present" style="top: 0px; display: block;">
            <p style="text-align:left">性能测试结果的分析在完成JMeter测试脚本执行后.首先要做的就是判断收集到的测试数据是否真实有效,对无效的测试数据进行分析,
                无端了浪费时间和精力.通常判断测试数据是否有效的方法如下:
            </p><ol>
            <li>分析在整个测试执行期间,测试环境是否稳定正常.
                常见异常:CPU占用达到100%,内存占用很高,测试网络出现拥塞导致响应延迟,待测系统参数配置错误(JDBC连接池等);</li>
            <li>检查JMeter测试脚本参数是否设置合理,建行擦JMeter运行模式是否合理,如Ramp-Up Period参数设置.</li>
            <li>检查测试结果是否暴露了系统瓶颈.重点关注异常的测试结果,如果测试结果一切正常,首先需要考虑的是并发数是否足够多,压测是否足够大,或者待测系统是否存在压力屏蔽机制等.</li>
        </ol>
            <p></p>
        </section>

        
        <section>
            <h3>7.参考文献</h3>
           <p>文献一:&nbsp https://blog.csdn.net/m0_37327416/article/details/78120465</P>
           <p>文献二:&nbsp http://www.cnblogs.com/yangxia-test/p/3964881.html<</P>
<!--           <p>文献三:&nbsp https://blog.csdn.net/xinxin19881112/article/details/5870677</P>-->
        </section>
        <section>
            <h4>鸣谢</h4>
            <p>感谢观看,如有出错,恳请指正</p>
            <p><small>BY : 杨棋</small></p>
        </section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
