<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="./css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="./css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="./lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
	<style>

	</style>
</head>
<body>
<img src="./img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>简单工厂模式</h2>
            <p>分享人：张强</p>	
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>            
            <p>4.编码实战</p>
            <p>5.扩展思考</p>
            <p>6.参考文献</p>
            <p>7.更多讨论</p>
        </section>
        
		<section>
			<h3>1.背景介绍</h3>
			<p>设计模式-GOF </p>
			<p>1994年由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版的 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）书中首次提到的，所以叫GOF</p>
		    <p>书中共有三个层面的内容：</p>
			<p>一、算是一个总结性的，把程序开发过程中<b style="">在不同系统中多次使用过的成功设计</b>的模式进行总结，用名称-问题-解决方案-实用效果这几个要素来描述</p>
			<p>二、提出了面向对象开发中“针对接口编程而不是针对实现编程”，“优先使用组合而不是继承”的总体设计思路</p>
			
		</section>
		<section>
			<p>三、就是基于上面的设计思路所形成的常用的设计模式，也就是现在流传最广的23种常见的设计模式</p>
			<!--<p>由于很早的时候都是面向编程的，后来面向对象编程，提高了很多效率，也有了许多好的设计模式。这些设计模式由GOF总结归纳，加上后来不断的实践总结已经是很成熟的设计思想了。我们应该熟悉这些设计模式，能应用到自己的代码中更好。</p>-->
			<p>概念</p>
			<p>许多人通晓并且使用的经过分类的代码设计经验的总结。</p>
			<p>设计模式是开发者们在开发过程中面临一般问题的解决方案，这些解决方案是经过相当长的一段时间的试验和错误总结出来的。设计模式几乎在所有的编程里都适用。</p>
			<p>目的</p>
			<p>为了提高代码可重用性、可扩展性、健壮性、更容易被理解。</p>
			<p>*当前说的设计模式是针对面向对象,而不是面向过程</p>
		</section>

		<section>
			<h3>2.知识剖析</h3>
			<p>工厂模式</p>
			<p>工厂是为了实现对构造过程（创建过程）的封装。也是设计原则的体现。工厂可以选择创建对象的逻辑，对这个构造过程进行选择的逻辑就是工厂。
			工厂模式主要思想就是替代new为我们创建对象，是一种创建型的设计模式。这样是为了给以后的系统带来更大的可扩展性，降低耦合。
			</p>
			<p>· 简单工厂模式</p>
			<p>· 工厂方法模式</p>
			<p>· 抽象工厂模式</p>
		</section>
		<section>
			<h3>简单（静态）工厂模式</h3>
			<p>简单工厂模式是最初自然而然就有的设计思想，它只是把创建过程比较自然的封装了一下，又称为静态工厂模式，是直接根据条件决定创建的产品。</p>
			<p>简单工厂模式由三部分组成：</p>
			<p>工厂角色（工厂/工厂抽象类）：它创建具体产品，实现了对创建过程（构造过程）的封装。也是设计原则的体现。工厂类里面是创建对象的逻辑，也就是对这个构造过程进行封装</p>
			<p>抽象产品角色（产品抽象/接口类）：工厂类所创建的产品的父类，或者说它们的共同接口</p>
			<p>具体产品角色（产品实体类）：工厂类所创建的任何对象都是这个角色的实例</p>
		</section>
		<section>
			<h3>工厂方法模式</h3>
			<p>由一个父类的工厂接口下面创建多个工厂实现类。每个子类工厂都对应生产自己负责的产品，然后由用户决定使用哪个工厂</p>
			<p></p>
		</section>
 
		<section>
			<h3>抽象工厂模式</h3>
			<p>抽象工厂就是对工厂方法进行扩展，在工厂类中再添加一个获取其它接口的实例的方法。工厂模式是创建一种产品，而抽象工厂模式是创建出一类产品。它创建更多的产品类，比如衣服有很多种，居家，商务，休闲，男装，女装等等。比如植物有很多类，当我们需要更多类型果实（产品）的时候就需要分更多的类。这就需要一个工厂类的抽象接口植物，然后下面有很多细分的工厂子类：比如水果/蔬菜/等等每个品种都需要一个工厂，我们需要苹果的时候就需要用工厂接口创建子类——水果工厂，再通过水果工厂来创建我们需要的苹果，其实跟工厂模式很像，只是多添加了一个功能。</p>
			<p></p>
		</section>

		<section>
			<h3>3.常见问题</h3>			
			<p>设计模式</p>
			<p>设计原则</p>

		</section>
		<section>
			<h3>设计模式</h3>
			<p>· 设计模式只是思路，并不能解决所有问题</p>
			<p>· 不要强制使用，它是用来解决问题，而不是寻找问题</p>
			<p>· 一定要在对的地方使用，不然只会适得其反</p>
		</section>

		<section>
			<p>1.创建型模式 ： 专注于如何初始化对象，就是在创建对象的同时隐藏创建逻辑，避免去使用new直接实例化对象</p>
			<p>模式有工厂、单例、建造者、原型模式等等</p>
			<p>2.结构型模式 ： 结构型模式是针对类和对象的组合，思想是如何组合类和对象以获得更大/更好的结构</p>
			<p>模式有桥接、适配器、装饰、委托、享元、组合模式等等</p>
			<p>3.行为型模式 ：关心的是对象之间的责任分配，它不仅仅指定结构，而且还概述了它们之间的消息传递的模式</p>
			<p>模式有命令、观察者、访问者、迭代器、中介者、策略模式等等</p>
		</section>

		<section>
			<h3>设计原则（不分先后）</h3>
			<p>一是开闭原则：对扩展是开放的，对修改是关闭的。也就是只能添加，不能修改。比如：游戏/软件更新，只通过扩展修改，而不是更改原有的代码。<br/>
			二是LoD（迪米特）法则：一个对象尽可能对其它对象少了解，只关心自己。即尽可能少的与其它对象发生联系，尽量少依赖。或者说”只与直接的朋友通讯“。</p>
		</section>
		<section>
			<p>三是依赖倒置（DIP）原则：高层不应依赖低层模块，两者都应该依赖它们的抽象；抽象也不应该依赖细节，而是细节依赖抽象。
比如A依赖B，如果需求改了，需要修改A的依赖为C的话就必须修改A的代码。大多数情况下A属于高层模块，B和C属于低层模块。依赖倒置原则就是把A依赖的B和C都实现接口F，而让A通过接口F间接的依赖B或者C，这样就会降低修改A的情况</p>
		</section>
		<section>
		<!--但是当一个类面临职责扩散的时候，如果修改它会造成更大的繁琐和复杂度，，不过这也会造成后续职责扩散到我们无法控制的程度-->
			<p>四是单一职责：非常简单的概述：一个类只有一个职责，它只负责份内的事。在任何时候都应该遵循它，这是所有设计原则的基础。</p>
			<p>五是里氏替换原则：通俗的来说就是子类可以扩展父类，但不能改变父类原有的方法。（因为修改很可能会造成整个继承体系的破坏，这也是继承的风险）</p>
		</section>
		<section>
			<p>六是接口隔离原则：客户端不应该依赖它不需要的接口，一个类的依赖应该建立在最小接口上
			比如有一个接口I，它的实现类有两个：C和D,这时候A通过I去依赖C，B通过I依赖D.如果I对于A和B来说不是最小的接口（接口中还有其它方法），那么C和D这两个实现类就必须实现它们不需要实现的方法。比如A和B需要的都要在C里面有，这样C就会做额外的动作。这种情况就需要把I拆分为独立的几个更小的接口，然后把AC和BD都分离开来，让他们和自己需要的接口建立依赖。</p>
		</section>
		<section>
			<p>七是合成复用原则（Composite Reuse Principle）:
尽量首先使用组合的方式，而不是使用继承。在面向对象设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生改变，则子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了合成/聚合复用原则，也就是在实际开发设计中，尽量使用合成/聚合，不要使用类继承。</p>
		</section>

		<section>
			<h3>4.编码实战</h3>
		</section>
	
		<section>
			<h3>5.扩展思考</h3>
			<p>简单工厂模式的优点和缺点</p>
			<p>优点：封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样可以降低代码的耦合度，降低维护成本，提高以后的扩展性 </p>
			<p>缺点：工厂类的职责比较大，如果修改需求或者需要添加新产品的话除了需要创建产品类，还要修改工厂类，而且如果工厂类出现问题的话所有的客户端（使用方）都会出现问题。
			但是工厂模式完美的解决了这个问题，完全遵循了开闭原则，只需要添加新的工厂类实现抽象接口就可以了。
			</p>
		</section>
		<section>			
			<p>简单提一下面向过程</p>
			<p>面向过程就是一种实际的思考方式，它关心的是某个事件，某个过程：比如起床-穿衣洗漱—吃饭-上班-工作-吃饭-下班-吃饭-睡觉这个过程</p>
			<p>面向过程就是一步一步实现这些步骤，依照顺序，先有起床-然后穿衣-洗漱再接着继续实现后面的步骤。这就是大概的面向过程的开发思想</p>
			<p>如果用面向对象可能就是抽象出一个上班族的类，然后包括这几个方法，它也一样可以实现这几个步骤，但是它的灵活性更强大，可以直接实现它的方法而不需要在意前后做了什么</p>
		</section>
		<section>
			<h3>6.参考文献</h3>
			<p>百度：工厂模式</p>
			<p>大话设计模式</p>
			<p>知乎</p>
		</section>
        
        <section>
            <h3>7.更多讨论</h3>
        </section>
        
        <section>
            <h4>分享到此结束</h4>
            <p>欢迎大家讨论</p>            
        </section>

    </div>
</div>

<script src="./lib/reveal/js/head.min.js"></script>
<script src="./lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: './plugin/markdown/marked.js' },
            { src: './plugin/markdown/markdown.js' },
            { src: './plugin/notes/notes.js', async: true },
            { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
